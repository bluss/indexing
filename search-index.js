var searchIndex = {};
searchIndex["indexing"] = {"doc":"Sound unchecked indexing in Rust using “generativity”; a type system\napproach to indices and ranges that are trusted to be in bounds.","items":[[3,"IndexingError","indexing","Error produced when an indexing operation is out of bounds or otherwise\ninapplicable.",null,null],[3,"Container","","A branded container, that allows access only to indices and ranges with\nthe exact same brand in the `&#39;id` parameter.",null,null],[3,"Index","","A branded index.",null,null],[3,"Range","","A branded range.",null,null],[3,"RangeIter","","An iterator over the indices in a range.",null,null],[3,"Subdivide","","`Subdivide` is an iterator of evenly sized nonempty, nonoverlapping ranges",null,null],[4,"NonEmpty","","Length marker for range known to not be empty.",null,null],[4,"Unknown","","Length marker for unknown length.",null,null],[5,"indices","","Create an indexing scope for a container.",null,{"inputs":[{"name":"array"},{"name":"f"}],"output":{"name":"out"}}],[0,"algorithms","","",null,null],[5,"quicksort","indexing::algorithms","Simple quicksort implemented using `indexing`,",null,null],[5,"quicksort_bounds","","quicksort implemented using regular bounds checked indexing",null,null],[5,"insertion_sort_indexes","","",null,null],[5,"insertion_sort_ranges","","",null,null],[5,"insertion_sort_pointerindex","","",null,null],[5,"insertion_sort_rust","","Copied from rust / libcollections/slice.rs, using raw pointers",null,null],[5,"merge_internal_indices","","Merge internal: Merge inside data while using `buffer` as a swap space",null,null],[5,"merge_internal_ranges","","Merge internal: Merge inside data while using `buffer` as a swap space",null,null],[5,"heapify","","",null,null],[5,"binary_search","","",null,null],[8,"Data","","Convenience trait -- debugging",null,null],[11,"eq","indexing","",0,null],[11,"ne","","",0,null],[11,"fmt","","",0,null],[11,"clone","","",0,null],[11,"description","","",0,null],[11,"fmt","","",0,null],[8,"Buffer","","A marker trait for collections where we can safely vet indices",null,null],[8,"BufferMut","","",null,null],[8,"ProofAdd","","Represents the combination of two proofs `P` and `Q` by a new type `Sum`.",null,null],[16,"Sum","","",1,null],[8,"IntoCheckedRange","","",null,null],[10,"into","","",2,null],[11,"fmt","","",3,null],[11,"clone","","",3,null],[11,"partial_cmp","","",4,null],[11,"lt","","",4,null],[11,"le","","",4,null],[11,"gt","","",4,null],[11,"ge","","",4,null],[11,"clone","","",4,null],[11,"integer","","",4,null],[11,"fmt","","",4,null],[11,"eq","","",4,null],[11,"fmt","","",5,null],[11,"clone","","",5,null],[11,"fmt","","",6,null],[11,"clone","","",6,null],[11,"len","","",3,null],[11,"empty_range","","Return the range [0, 0)",3,null],[11,"range","","Return the full range of the Container.",3,null],[11,"vet","","",3,null],[11,"vet_range","","",3,null],[11,"split_at","","",3,null],[11,"split_after","","Split in two ranges, where the first includes the `index` and the second\nstarts with the following index.",3,null],[11,"split_around","","Split around the Range `r`: Return ranges corresponding to `0..r.start`\nand `r.end..`.",3,null],[11,"before","","Return the range before (not including) the index itself",3,null],[11,"after","","Return the range after (not including) the index itself",3,null],[11,"forward","","Increment `index`, if doing so would still be in bounds.",3,null],[11,"forward_by","","Increment `index`, if doing so would still be in bounds.",3,null],[11,"forward_range_by","","Increment `r`, clamping to the end of the Container.",3,null],[11,"backward","","Decrement `index`, if doing so would still be in bounds.",3,null],[11,"scan_from","","Examine the elements after `index` in order from lower indices towards higher.\nWhile the closure returns `true`, continue scan and include the scanned\nelement in the range.",3,null],[11,"scan_from_rev","","Examine the elements before `index` in order from higher indices towards lower.\nWhile the closure returns `true`, continue scan and include the scanned\nelement in the range.",3,null],[11,"scan_range","","Examine the elements `range` in order from lower indices towards higher.\nWhile the closure returns `true`, continue scan and include the scanned\nelement in the range.",3,null],[11,"swap","","Swap elements at `i` and `j` (they may be equal).",3,null],[11,"rotate1_up","","Rotate elements in the range `r` by one step to the right (towards higher indices)",3,null],[11,"rotate1_down","","Rotate elements in the range `r` by one step to the left (towards lower indices)",3,null],[11,"index_twice","","Index by two nonoverlapping ranges, where `r` is before `s`.",3,null],[11,"zip_mut_raw","","Zip by raw pointer (will be indentical if ranges have same starting point)",3,null],[11,"index","","",3,null],[11,"index_mut","","",3,null],[11,"index","","",3,null],[11,"index_mut","","",3,null],[11,"index","","",3,null],[11,"index_mut","","",3,null],[11,"index","","",3,null],[11,"index_mut","","",3,null],[11,"index","","",3,null],[11,"index_mut","","",3,null],[11,"index","","",3,null],[11,"index","","",3,null],[11,"clone","","",7,null],[11,"eq","","",7,null],[11,"len","","Return the length of the range.",7,null],[11,"is_empty","","Return `true` if the range is empty.",7,null],[11,"nonempty","","Try to create a proof that the Range is nonempty; return\na `Result` where the `Ok` branch carries a non-empty Range.",7,null],[11,"start","","Return the start index.",7,null],[11,"end","","Return the end index.",7,null],[11,"split_in_half","","Split the range in half, with the upper middle index landing in the\nlatter half. Proof of length `P` transfers to the latter half.",7,null],[11,"split_at","","Split to length `index`; if past the end, return false and clamp to the end",7,null],[11,"contains","","`abs_index` is an absolute index",7,null],[11,"subdivide","","Return an iterator that divides the range in `n` parts, in as\neven length chunks as possible.",7,null],[11,"join","","Join together two adjacent ranges (they must be exactly touching, and\nin left to right order).",7,null],[11,"join_cover","","Extend the range to the end of `other`, including any space in between",7,null],[11,"join_cover_both","","Extend the range to start and end of `other`, including any space in between",7,null],[11,"as_range","","",7,null],[11,"frontiers","","Return two empty ranges, at the front and the back of the range respectively",7,null],[11,"forward_by","","Increment `index`, if doing so would still be before the end of the range",7,null],[11,"forward_range_by","","Increment `r`, clamping to the end of `self`.",7,null],[11,"no_proof","","",7,null],[11,"fmt","","",7,null],[11,"into","","",7,null],[11,"into","","",7,null],[11,"first","","",7,null],[11,"lower_middle","","Return the middle index, rounding down.",7,null],[11,"upper_middle","","Return the middle index, rounding up.",7,null],[11,"last","","",7,null],[11,"tail","","",7,null],[11,"init","","",7,null],[11,"advance_","","",7,null],[11,"advance","","Increase the range&#39;s start, if the result is still a non-empty range.",7,null],[11,"advance_by","","Increase the range&#39;s start, if the result is still a non-empty range.",7,null],[11,"advance_back","","Decrease the range&#39;s end, if the result is still a non-empty range.",7,null],[11,"into_iter","","",7,null],[11,"fmt","","",8,null],[11,"clone","","",8,null],[11,"into_range","","",8,null],[11,"next","","",8,null],[11,"next_back","","",8,null],[11,"fmt","","",9,null],[11,"clone","","",9,null],[11,"next","","",9,null]],"paths":[[3,"IndexingError"],[8,"ProofAdd"],[8,"IntoCheckedRange"],[3,"Container"],[3,"Index"],[4,"NonEmpty"],[4,"Unknown"],[3,"Range"],[3,"RangeIter"],[3,"Subdivide"]]};
initSearch(searchIndex);
